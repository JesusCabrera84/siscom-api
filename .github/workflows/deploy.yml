name: Deploy to EC2

on:
  push:
    branches:
      - master
  workflow_dispatch: # Permite ejecuci√≥n manual

env:
  IMAGE_NAME: siscom-api
  IMAGE_TAG: ${{ github.sha }}
  CONTAINER_NAME: siscom-api

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    environment: test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install linting dependencies
        run: |
          python -m pip install --upgrade pip
          pip install ruff black mypy

      - name: Run Ruff (linter)
        run: |
          echo "üîç Ejecutando Ruff..."
          ruff check app/

      - name: Run Black (formatter)
        run: |
          echo "üé® Verificando formato con Black..."
          black --check app/

      # MyPy deshabilitado - puedes ejecutarlo localmente con: make type-check
      # - name: Run MyPy (type checker)
      #   continue-on-error: true
      #   run: |
      #     echo "üìù Verificando tipos con MyPy..."
      #     mypy app/ --ignore-missing-imports

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          tags: siscom-api:latest
          no-cache: true  # ‚ö†Ô∏è TEMPORAL: Desactivar cach√© para rebuild con aio-statsd
          load: true

      - name: Save Docker image
        run: |
          docker save ${{ env.IMAGE_NAME }}:latest | gzip > siscom-api.tar.gz

      - name: Copy files to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_SSH_PORT }}
          source: "siscom-api.tar.gz,docker-compose.yml"
          target: "/home/${{ secrets.EC2_USERNAME }}/siscom-api"

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          DB_HOST: ${{ vars.DB_HOST }}
          DB_PORT: ${{ vars.DB_PORT }}
          DB_USERNAME: ${{ vars.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_DATABASE: ${{ vars.DB_DATABASE }}
          DB_MIN_CONNECTIONS: ${{ vars.DB_MIN_CONNECTIONS }}
          DB_MAX_CONNECTIONS: ${{ vars.DB_MAX_CONNECTIONS }}
          DB_CONNECTION_TIMEOUT_SECS: ${{ vars.DB_CONNECTION_TIMEOUT_SECS }}
          DB_IDLE_TIMEOUT_SECS: ${{ vars.DB_IDLE_TIMEOUT_SECS }}
          BROKER_HOST: ${{ vars.BROKER_HOST }}
          BROKER_TOPIC: ${{ vars.BROKER_TOPIC }}
          MQTT_USERNAME: ${{ vars.MQTT_USERNAME }}
          MQTT_PASSWORD: ${{ vars.MQTT_PASSWORD }}
          STATSD_HOST: ${{ vars.STATSD_HOST }}
          STATSD_PORT: ${{ vars.STATSD_PORT }}
          STATSD_PREFIX: ${{ vars.STATSD_PREFIX }}
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_SSH_PORT }}
          envs: IMAGE_NAME,CONTAINER_NAME,DB_HOST,DB_PORT,DB_USERNAME,DB_PASSWORD,DB_DATABASE,DB_MIN_CONNECTIONS,DB_MAX_CONNECTIONS,DB_CONNECTION_TIMEOUT_SECS,DB_IDLE_TIMEOUT_SECS,BROKER_HOST,BROKER_TOPIC,MQTT_USERNAME,MQTT_PASSWORD,STATSD_HOST,STATSD_PORT,STATSD_PREFIX
          script: |
            cd /home/${{ secrets.EC2_USERNAME }}/siscom-api
            
            # Cargar la nueva imagen
            docker load < siscom-api.tar.gz
            
            # Crear la red si no existe
            docker network inspect siscom-network >/dev/null 2>&1 || docker network create siscom-network
            
            # Crear archivo .env con las variables
            cat > .env << EOF
            DB_HOST=${DB_HOST}
            DB_PORT=${DB_PORT}
            DB_USERNAME=${DB_USERNAME}
            DB_PASSWORD=${DB_PASSWORD}
            DB_DATABASE=${DB_DATABASE}
            DB_MIN_CONNECTIONS=${DB_MIN_CONNECTIONS}
            DB_MAX_CONNECTIONS=${DB_MAX_CONNECTIONS}
            DB_CONNECTION_TIMEOUT_SECS=${DB_CONNECTION_TIMEOUT_SECS}
            DB_IDLE_TIMEOUT_SECS=${DB_IDLE_TIMEOUT_SECS}
            BROKER_HOST=${BROKER_HOST}
            BROKER_TOPIC=${BROKER_TOPIC}
            MQTT_USERNAME=${MQTT_USERNAME}
            MQTT_PASSWORD=${MQTT_PASSWORD}
            JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
            JWT_ALGORITHM=HS256
            ACCESS_TOKEN_EXPIRE_MINUTES=60
            ALLOWED_ORIGINS=*
            STATSD_HOST=${STATSD_HOST}
            STATSD_PORT=${STATSD_PORT}
            STATSD_PREFIX=${STATSD_PREFIX}
            EOF
            
            # Detener y eliminar el contenedor existente
            docker-compose down || true
            
            # Levantar el nuevo contenedor
            docker-compose up -d
            
            # Esperar a que el contenedor est√© saludable
            echo "Esperando a que el contenedor est√© saludable..."
            CONTAINER_HEALTHY=false
            for i in {1..30}; do
              STATUS=$(docker inspect --format="{{.State.Health.Status}}" ${CONTAINER_NAME} 2>/dev/null || echo "not_found")
              echo "Intento $i/30: Status = $STATUS"
              
              if [ "$STATUS" = "healthy" ]; then
                echo "‚úÖ Contenedor est√° healthy!"
                CONTAINER_HEALTHY=true
                break
              elif [ "$STATUS" = "unhealthy" ]; then
                echo "‚ùå ERROR: Contenedor est√° unhealthy"
                echo "Logs del contenedor:"
                docker logs --tail 50 ${CONTAINER_NAME}
                exit 1
              fi
              
              sleep 2
            done
            
            if [ "$CONTAINER_HEALTHY" = false ]; then
              echo "‚ùå ERROR: Timeout esperando que el contenedor est√© healthy"
              echo "Estado actual: $(docker inspect --format="{{.State.Status}}" ${CONTAINER_NAME})"
              echo "Logs del contenedor:"
              docker logs --tail 50 ${CONTAINER_NAME}
              exit 1
            fi
            
            # Verificar logs en busca de errores cr√≠ticos
            echo "Verificando logs en busca de errores..."
            if docker logs ${CONTAINER_NAME} 2>&1 | grep -q "Application startup failed"; then
              echo "‚ùå ERROR: La aplicaci√≥n fall√≥ al iniciar"
              docker logs --tail 50 ${CONTAINER_NAME}
              exit 1
            fi
            
            # Limpiar im√°genes antiguas
            docker image prune -f
            
            # Eliminar el archivo tar.gz
            rm -f siscom-api.tar.gz
            
            echo "‚úÖ Deployment completado exitosamente!"

      - name: Verify deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_SSH_PORT }}
          script: |
            echo "=== Verificaci√≥n Final del Deployment ==="
            echo ""
            
            # Verificar que el contenedor est√° corriendo
            echo "1. Estado del contenedor:"
            if ! docker ps | grep siscom-api; then
              echo "‚ùå ERROR: El contenedor siscom-api no est√° corriendo"
              exit 1
            fi
            echo "‚úÖ Contenedor corriendo"
            echo ""
            
            # Verificar health status
            echo "2. Health status:"
            HEALTH_STATUS=$(docker inspect --format="{{.State.Health.Status}}" siscom-api)
            echo "Status: $HEALTH_STATUS"
            if [ "$HEALTH_STATUS" != "healthy" ]; then
              echo "‚ùå ERROR: Contenedor no est√° healthy"
              exit 1
            fi
            echo "‚úÖ Contenedor healthy"
            echo ""
            
            # Verificar que no hay errores cr√≠ticos en logs
            echo "3. Verificando logs recientes:"
            RECENT_LOGS=$(docker logs --tail 50 siscom-api 2>&1)
            
            if echo "$RECENT_LOGS" | grep -q "Application startup failed"; then
              echo "‚ùå ERROR: Aplicaci√≥n fall√≥ al iniciar"
              echo "$RECENT_LOGS"
              exit 1
            fi
            
            if echo "$RECENT_LOGS" | grep -q "ModuleNotFoundError"; then
              echo "‚ùå ERROR: M√≥dulo faltante"
              echo "$RECENT_LOGS"
              exit 1
            fi
            
            if echo "$RECENT_LOGS" | grep -E "ERROR.*Exiting" | grep -v "test"; then
              echo "‚ùå ERROR: Error cr√≠tico encontrado en logs"
              echo "$RECENT_LOGS"
              exit 1
            fi
            
            echo "‚úÖ No se encontraron errores cr√≠ticos"
            echo ""
            
            # Verificar que el health endpoint responde
            echo "4. Verificando health endpoint:"
            CONTAINER_IP=$(docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' siscom-api)
            if curl -f -s http://localhost:8000/health > /dev/null 2>&1 || curl -f -s http://$CONTAINER_IP:8000/health > /dev/null 2>&1; then
              echo "‚úÖ Health endpoint responde correctamente"
            else
              echo "‚ö†Ô∏è  Warning: No se pudo verificar el health endpoint (puede ser normal si hay firewall)"
            fi
            echo ""
            
            echo "üéâ Deployment verificado exitosamente!"
            echo ""
            echo "=== √öltimos logs (informativos) ==="
            docker logs --tail 20 siscom-api

      - name: Notification on failure
        if: failure()
        run: |
          echo "Deployment failed! Check the logs above for details."
          # Aqu√≠ puedes agregar notificaciones a Slack, Discord, email, etc.

